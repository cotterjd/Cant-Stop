{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte"
  ],
  "sourcesContent": [
    "<h1>Can't Stop! &nbsp; &nbsp; <span style=\"color: {state.player === 1 ? 'blue' : 'red'};\">Player {state.player} Turn</span></h1>\n<!--<div class=\"debug\">\n  {JSON.stringify(state)}\n</div>-->\n\n{#each state.activeChips as chip}\n\t<span class=\"active-chip\" \n\t\t\t\tstyle=\"top: {chip.location[1]}px; left: {chip.location[0]}px\"/>\n  <span class=\"active-chip\" \n\t\t\t\tstyle=\"top: {chip.location[1]}px; left: {chip.location[0]}px\"/>\n  <span class=\"active-chip\" \n\t\t\t\tstyle=\"top: {chip.location[1]}px; left: {chip.location[0]}px\"/>\n{/each}\n\n{#each Object.keys(state.player1Chips) as key}\n  <span class=\"player1-chip\" \n\t\t\t\tstyle={getLocationStyles(key, `player1Chips`)} />\n{/each}\n{#each Object.keys(state.player2Chips) as key}\n  <span class=\"player2-chip\" \n\t\t\t\tstyle={getLocationStyles(key, `player2Chips`)} />\n{/each}\n\n\n<div class=\"btn-container\">\n\t<button on:click={lockInGains}>stop</button> \n\t<button on:click={roleDice}>roll!</button> \n\t<div>\n\t\tRole:\n\t\t<span>{die1}</span>\n\t\t<span>{die2}</span>\n\t\t\n\t\t<span>{die3}</span>\n\t\t<span>{die4}</span>\n\t\t<div>\n\t\t\t<p>Possiblities</p>\n\t\t\t{#each ps as p }\n\t\t\t\t<div>\n\t\t\t\t\t<button on:click={moveChips(p)}>{p}</button>\n\t\t\t\t</div>\n\t\t\t{/each}\n\t\t</div>\n\t</div>\n</div>\n\n<div class=\"border\" />\n\n{#each ascCols as col }\n  <div class=\"col-c\" \n\t\t\t style=\"\n\t\t\t\t\t\t\ttop: {ascTop-40*(col[0]-1)}px;\n\t\t\t\t\t\t\tleft: {ascLeft+40*(col[0]-1)}px;\n\t\t\t\t\t\t\"\n\t\t\t >\n\t\t<div class=\"col\" style=\"{state.colColors[col[0]]};\">\n\t\t\t{#each col as x}\n\t\t\t  <span style=\"padding: 1px;\">{x}</span>\n\t\t\t  &nbsp;\n\t\t\t{/each}\n\t\t</div>\t\t\n</div>\n\n{/each}\n{#each descCols as col }\n  <div class=\"col-c\" \n\t\t\t style=\"\n\t\t\t\t\t\t\ttop: {descTop+40*(col[0]-1)}px;\n\t\t\t\t\t\t\tleft: {descLeft+40*(col[0]-1)}px;\n\t\t\t\t\t\t\"\n\t>\n\t\t<div class=\"col\" style=\"{state.colColors[col[0]]};\">\n\t\t\t{#each col as x}\n\t\t\t  <span style=\"padding: 1px;\">{x}</span>\n\t\t\t  &nbsp;\n\t\t\t{/each}\n\t\t</div>\t\t\n</div>\n{/each}\n\n<script>\n  \n\tlet foo = `black`\n  const chip1Home = [120, 100]\n\t, chip2Home = [87, 140]\n\t, chip3Home = [87, 100]\n\t, defaultChips = Object.freeze([Object.freeze({\n\t\t  id: 1,\n\t\t  isAvailable: true,\n\t\t  rope: 0,\n\t\t  position: 0,\n\t\t  location: chip1Home,\n\t  }),Object.freeze({\n\t\t  id: 2,\n\t\t  isAvailable: true,\n\t\t  rope: 0,\n\t\t\tposition: 0,\n\t\t  location: chip2Home,\n\t  }),Object.freeze({\n\t\t  id: 3,\n\t\t  isAvailable: true,\n\t\t  rope: 0,\n\t\t\tposition: 0,\n\t\t  location: chip3Home,\n\t  })])\n\t, defaultPlayerChips = Object.freeze({\n\t\t  1: 0,\n\t\t  2: 0,\n\t\t  3: 0,\n\t\t  4: 0,\n\t\t  5: 0,\n\t\t  6: 0,\n\t\t  7: 0,\n\t\t  8: 0,\n\t\t  9: 0,\n\t\t  10: 0,\n\t\t  11: 0,\n\t\t  12: 0,\n\t  })\n\t\n\t, getLocationStyles = (key, pStr) => {\n\t\t  const pChips = state[pStr]\n\t\t\tconst loc = getLocation(key, pChips)\n\t\t\tif (pStr === `player1Chips`) {\n\t\t\t\treturn `position:absolute; top: ${loc[1]}px; left: ${loc[0]-5}px;` \n\t\t\t} else if (pStr === `player2Chips`) {\n\t\t\t\treturn `position:absolute; top: ${loc[1]}px; left: ${loc[0]+5}px;` \n\t\t\t}\n\n\t  }\n\t\n\t, getLocation = (key, playerChips) => {\n\t\t  if (playerChips[key] === 0) return [0, 0]\n\t\t  return ropePositions[key][playerChips[key]-1]\n\t  }\n\t\n\t, state = {\n\t\t  player: 1,\n\t\t  activeChips: [ ...defaultChips ],\n\t\t  player1Chips: { ...defaultPlayerChips },\n\t\t  player1Ropes: [], // deprecated\n\t\t  player2Chips: { ...defaultPlayerChips },\n\t\t  player2Ropes: [], //deprecated\n\t\t  ownedRopes: [],\n\t\t  colColors: {\n\t\t  2: `border: 1px solid black`,\n\t\t  3: `border: 1px solid black`,\n\t\t  4: `border: 1px solid black`,\n\t\t  5: `border: 1px solid black`,\n\t\t  6: `border: 1px solid black`,\n\t\t  7: `border: 1px solid black`,\n\t\t  8: `border: 1px solid black`,\n\t\t  9: `border: 1px solid black`,\n\t\t  10: `border: 1px solid black`,\n\t\t  11: `border: 1px solid black`,\n\t\t  12: `border: 1px solid black`,\n\t  }\n\t  }\n\t, ascTop = 370\n\t, ascLeft = 240\n\t, descTop = -110\n\t, descLeft= 240\n\t, ascCols = Object.freeze([\n      Array(2).fill(2),\n\t\t  Array(4).fill(3),\n\t\t  Array(6).fill(4),\n\t\t  Array(8).fill(5),\n\t\t  Array(10).fill(6),\n\t\t  Array(12).fill(7),\n\t  ])\n\t// -> [Array]\n\t, descCols = Object.freeze([\n\t\t  Array(10).fill(8),\n\t\t  Array(8).fill(9),\n\t\t  Array(6).fill(10),\n\t\t  Array(4).fill(11),\n\t\t  Array(2).fill(12),\n\t  ])\n\t, player1Chips = { ...defaultPlayerChips }\n\t, player2Chips = { ...defaultPlayerChips }\n  , ropeLocations = Object.freeze([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\t\t  .reduce((a, x, i) => ({\n\t\t\t\t...a, \n\t\t\t\t[x]: 320 + (40*(i-1)),\n\t\t\t}), {}))\n\t\n\t// Int -> Int -> [Int, Int] -> Int -> Object\n   , getRopeLocations = (rope, ropeLen, startingPosition, incrementAmount) => {\n\n\t\t   const ropeLocs = Array(ropeLen).fill(rope).reduce((a, x, i) => {\n\t\t\t   const nextPos = a.curPos - incrementAmount\n\t\t\t   return {\n\t\t\t\t   ...a,\n\t\t\t\t   [i]: [getX(x), nextPos],\n\t\t\t\t   curPos: nextPos,\n\t\t\t   }\n\t\t   }, {curPos: startingPosition})\n\n\t\t   return ropeLocs\n\t  }\n\t// -> Object\n\t, ropePositions = Object.freeze({\n\t\t  2: getRopeLocations(2, 3, 415, 37),\n\t\t  3: getRopeLocations(3, 5, 445, 37),\n\t\t  4: getRopeLocations(4, 7, 475, 37),\n\t\t  5: getRopeLocations(5, 9, 515, 37),\n\t\t  6: getRopeLocations(6, 11, 550, 37),\n\t\t  7: getRopeLocations(7, 13, 585, 37),\n\t\t  8: getRopeLocations(8, 11, 550, 37),\n\t\t  9: getRopeLocations(9, 9, 515, 37),\n\t\t  10: getRopeLocations(10, 7, 475, 37),\n\t\t  11: getRopeLocations(11, 5, 445, 37),\n\t\t  12: getRopeLocations(12, 3, 415, 37),\n\t  })\n\t;\n\n\tlet startingPositions = { ...defaultPlayerChips }\n\t\n\tfunction moveChips(ps) {\n\n\t\tmoveChip(ps[0])\n\t\tif (ps[1]) moveChip(ps[1])\n\t}\n\tfunction moveChip (rope) {\n\t\tconst playerRopePos = startingPositions[rope]\n\t\t\n\t\tconst chipOnRope = state.activeChips.find(chip => {\n\t\t\tif (chip.rope === rope) return chip\n\t\t})\n\n\t\tconst availableChip = state.activeChips.find(x => x.isAvailable)\n  \n\t\tconst chipToUse = chipOnRope || availableChip\n\t\tconst playerChips = state.player === 1 ? state.player1Chips : state.player2Chips\n\t\tconst playerPosition = playerChips[rope]\n\t\tconst position = (chipToUse.position || playerPosition) + 1 \n\n\t\tconst location = getNewLocation(rope, playerRopePos)\n\n\t  const updatedChip = {\n\t\t\t...chipToUse,\n\t\t\tlocation,\n\t\t\tisAvailable: false,\n\t\t\trope,\n\t\t\tposition,\n\t  }\n\n\t\tstate.activeChips = state.activeChips.map(x => {\n\t\t\tif (x.id === updatedChip.id) return updatedChip\n\t\t\treturn x\n\t\t})\t\n\n\t\tstartingPositions[rope] = startingPositions[rope]+1\n\t}\n  function getNewLocation (rope, playerPos) {\n\t\treturn ropePositions[rope][playerPos]\n\t}\n\tfunction playerGetsRope (rope) {\n\t\tif (state.player === 1) {\n\t\t\tcolColors[rope] = `blue`\n\t\t\tstate.Player1Ropes = state.player1Ropes.concat(rope)\n\t\t}\n\t\telse if (state.player === 2) {\n\t\t\tcolColors[rope] = `red`\n\t\t\tstate.Player2Ropes = state.player2Ropes.concat(rope)\n\t\t}\n\t}\n\tfunction getX (rope) {\n\t\treturn ropeLocations[rope]\n\t}\n\tlet ps = []\n\tlet die1 = `3`\n\tlet die2 = `1`\n\tlet die3 = `6`\n\tlet die4 = `3`\n\tfunction roleDice () {\n    ps = [] // reset\n\t\tconst role = () => Math.floor(Math.random()*6+1)\n\t\tdie1 = role()\n\t\tdie2 = role()\n\t\tdie3 = role()\n\t\tdie4 = role()\n\n\t\tconst combinations = [\n\t\t\t[\n\t\t\t\tNumber(die1) + Number(die2), \n\t\t\t  Number(die3) + Number(die4),\n\t\t\t],\n\t\t\t[\n\t\t\t\tNumber(die1) + Number(die3),\n\t\t\t\tNumber(die2) + Number(die4),\n\t\t\t],\n\t\t\t[\n\t\t\t\tNumber(die1) + Number(die4),\n\t\t\t\tNumber(die2) + Number(die3),\n\t\t\t]\n\t\t]\n\t\t\n\t\tps = combinations.reduce((a, [x1, x2]) => {\n\t\t\tif (playerHasActiveChipOnNumber(x1) && playerHasActiveChipOnNumber(x2)) \n\t\t\t\treturn [...a, [x1, x2]]\n\t\t\tif (playerHasTwoAvailableChips(x1, x2)) return [...a, [x1, x2]]\n\t\t\tif (playerHasAvailableChip(x1) && playerHasActiveChipOnNumber(x2)) \n\t\t\t\treturn [...a, [x1, x2]]\n\t\t\tif (playerHasAvailableChip(x2) && playerHasActiveChipOnNumber(x1)) \n\t\t\t\treturn [...a, [x1, x2]]\n\t\t\tif (playerHasAvailableChip(x1)) return [...a, [x1]]\n\t\t\tif (playerHasAvailableChip(x2)) return [...a, [x2]]\n\t\t\tif (playerHasActiveChipOnNumber(x1)) return [...a, [x1]]\n\t\t\tif (playerHasActiveChipOnNumber(x2)) return [...a, [x2]]\n\t\t\t/*if (playerHasActiveChipOnNumber(x1) && playerHasActiveChipOnNumber(x2)) \n\t\t\t\treturn [...a, [x1, x2]]\n\t\t\tif (playerHasAvailableChip(x1, x2)) return [...a, [x1], [x2]]\n\t\t\tif (playerHasActiveChipOnNumber(x1)) return [...a, [x1]]\n\t\t\tif (playerHasActiveChipOnNumber(x2)) return [...a, [x2]]*/\n\t\t\treturn a\n\t\t}, [])\n\t\tif (!ps.length) {\n\t    alert(`lost turn!`)\n\t\t\treset()\n\t\t}\n\t}\n\tfunction ropeIsPlayable (rope) {\n\t\treturn !state.ownedRopes.includes(rope) && chipIsNotAtTop(rope)\n\t}\n\tfunction playerHasTwoAvailableChips (rope1, rope2) {\n\t\treturn state.activeChips.filter(x => x.isAvailable).length >= 2 \n\t\t\t&& ropeIsPlayable(rope1) && ropeIsPlayable(rope2)\n\t}\n\tfunction playerHasActiveChipOnNumber (rope) {\n\t\treturn !!state.activeChips.find(x => x.rope === rope)\n\t\t&& (!state.player1Ropes.includes(rope) && !state.player2Ropes.includes(rope))\n\t\t&& chipIsNotAtTop(rope)\n\t}\n\tfunction chipIsNotAtTop (rope) {\n\t\tconst chip = state.activeChips.find(x => x.rope === rope)\n\t\tif (!chip) return true\n\t\tconst maxPosition = Object.keys(ropePositions[rope]).length\n\t\treturn chip.position+1 !== maxPosition\n\t}\n\tfunction playerHasAvailableChip (rope) {\n\t\treturn !!state.activeChips.find(x => x.isAvailable) && ropeIsPlayable(rope)\n\t}\n\tfunction reset () {\n\t\tstate.player = state.player === 1 ? 2 : 1\n\t\tstate.activeChips = [ ...defaultChips ]\n\t\tif (state.player === 1) {\n\t\t\tstartingPositions = { ...state.player1Chips }\n\t\t} else {\n\t\t\tstartingPositions = { ...state.player2Chips }\n\t\t}\n\t}\n\tfunction lockInGains () {\n    updatePlayerPosition()\n\t\treset()\n\t}\n\tfunction updatePlayerPosition () {\n\t\tstate.activeChips.forEach(chip => {\n\t\t\tconst maxPosition = Object.keys(ropePositions[chip.rope]).length\n\t\t\tif (state.player === 1) {\n\t\t\t\tstate.player1Chips[chip.rope] = chip.position\n\t\t\t\tconsole.log(chip.position, maxPosition)\n\t\t\t\tif (chip.position+1 === maxPosition) {\n\t\t\t\t\tstate.colColors[chip.rope] = 'background-color: blue'\n\t\t\t\t\tstate.ownedRopes = state.ownedRopes.concat(chip.rope)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstate.player2Chips[chip.rope] = chip.position\n\t\t\t\tconsole.log(chip.position, maxPosition)\n\t\t\t\tif (chip.position+1 === maxPosition) {\n\t\t\t\t\tstate.colColors[chip.rope] = 'background-color: red'\n\t\t\t\t\tstate.ownedRopes = state.ownedRopes.concat(chip.rope)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n</script>\n<style>\n\t.border {\n\t\tborder: 4px solid black;\n\t\twidth: 370px;\n\t\theight: 370px;\n\t\ttransform: rotate(45deg);\n\t\tposition: absolute;\n\t\tleft: 299px;\n\t\ttop: 170px\n\t}\n\t.col-c {\n\t\tposition: absolute;\n\t}\n\t.col {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t}\n\t.active-chip {\n\t\tposition: absolute;\n\t\theight: 20px;\n\t\twidth: 20px;\n\t\tbackground-color: black;\n\t\tborder-radius: 50%;\n\t}\n\t.player1-chip {\n\t\tposition: absolute;\n\t\theight: 20px;\n\t\twidth: 20px;\n\t\tbackground-color: blue;\n\t\tborder-radius: 50%;\n\t}\n\t.player2-chip {\n\t\tposition: absolute;\n\t\theight: 20px;\n\t\twidth: 20px;\n\t\tbackground-color: red;\n\t\tborder-radius: 50%;\n\t}\n\t.btn-container {\n\t\tposition: absolute;\n\t\tright: 50px;\n\t}\n\t.debug {\n\t\tposition: absolute;\n\t\tbottom: 50px;\n\t}\n</style>\n\n"
  ],
  "names": [],
  "mappings": "AAyXC,OAAO,cAAC,CAAC,AACR,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CACvB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,SAAS,CAAE,OAAO,KAAK,CAAC,CACxB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,KAAK,CACX,GAAG,CAAE,KAAK;CACX,CAAC,AACD,MAAM,cAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,AACnB,CAAC,AACD,IAAI,cAAC,CAAC,AACL,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,AACvB,CAAC,AACD,YAAY,cAAC,CAAC,AACb,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,gBAAgB,CAAE,KAAK,CACvB,aAAa,CAAE,GAAG,AACnB,CAAC,AACD,aAAa,cAAC,CAAC,AACd,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,gBAAgB,CAAE,IAAI,CACtB,aAAa,CAAE,GAAG,AACnB,CAAC,AACD,aAAa,cAAC,CAAC,AACd,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,gBAAgB,CAAE,GAAG,CACrB,aAAa,CAAE,GAAG,AACnB,CAAC,AACD,cAAc,cAAC,CAAC,AACf,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,AACZ,CAAC"
}